<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas Drawing</title>
  <style>
    #canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas><br>
  <button onclick="setColor('#000000')">Black</button>
  <button onclick="setColor('#FF0000')">Red</button>
  <button onclick="setColor('#0000FF')">Blue</button>
  <button onclick="setColor('#FFFF00')">Yellow</button>
  <button onclick="setColor('#00FF00')">Green</button>
  <input type="color" id="colorPicker">
  <input type="range" id="brushSize" min="1" max="50" value="5">
  <input type="range" id="opacity" min="0" max="1" step="0.1" value="1">
  <button onclick="clearCanvas()">Clear</button>
  <button onclick="undo()">Undo</button>
  <button onclick="downloadCanvas()">Download</button>

  <script>
    const canvas = document.getElementById('canvas');
    const context = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let hue = '#000000'; // Default color
    let brushSize = 5; // Default brush size
    let opacity = 1; // Default opacity
    let drawingHistory = [];

    // Function to draw on canvas
    function draw(e) {
      if (!isDrawing) return;
      context.strokeStyle = hue;
      context.lineWidth = brushSize;
      context.lineJoin = 'round';
      context.lineCap = 'round';
      context.globalAlpha = opacity;
      context.beginPath();
      // Start from
      context.moveTo(lastX, lastY);
      // Go to
      context.lineTo(e.offsetX, e.offsetY);
      context.stroke();
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    // Event listeners
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    });
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
      saveDrawingState();
    });
    canvas.addEventListener('mouseout', () => {
      isDrawing = false;
      saveDrawingState();
    });

    // Function to clear canvas
    function clearCanvas() {
      context.clearRect(0, 0, canvas.width, canvas.height);
      saveDrawingState();
    }

    // Function to undo drawing
    function undo() {
      if (drawingHistory.length > 1) { // Check if there's anything to undo
        drawingHistory.pop(); // Remove current state
        context.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        context.putImageData(drawingHistory[drawingHistory.length - 1], 0, 0); // Restore previous state
      }
    }

    // Function to set color
    function setColor(color) {
      hue = color;
      document.getElementById('colorPicker').value = color; // Update color picker
    }

    // Color picker event
    const colorPicker = document.getElementById('colorPicker');
    colorPicker.addEventListener('input', () => {
      hue = colorPicker.value;
    });

    // Brush size event
    const brushSizeInput = document.getElementById('brushSize');
    brushSizeInput.addEventListener('input', () => {
      brushSize = brushSizeInput.value;
    });

    // Opacity event
    const opacityInput = document.getElementById('opacity');
    opacityInput.addEventListener('input', () => {
      opacity = opacityInput.value;
    });

    // Save drawing state to history
    function saveDrawingState() {
      if (isDrawing) {
        let currentState = context.getImageData(0, 0, canvas.width, canvas.height);
        drawingHistory.push(currentState);
      }
    }

    // Function to download canvas as image
    function downloadCanvas() {
      const dataURL = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = dataURL;
      link.download = 'drawing.png';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  </script>
</body>
</html>
